<p>Когда создается новый класс, он расширяется новыми свойствами. Из переданных, в качестве второго и последующих аргументов-объектов копируются свойства в прототип нового класса. Но перед тем как сохранить свойство, делается проверка &mdash; нет ли уже такого свойства в прототипе. Если значение есть и оно имеет метод <i>__extend__</i>, то вызывается этот метод, которому передается новое значение для прототипа, а в прототип сохраняется результат выполнения этого метода. В противном случае значение копируется в прототип как есть. Этот алгоритм иллюстрирует следующий код:</p>
<pre><b:text>
for (var key in extension)
{
  var curValue = newClass.prototype[key];
  newClass.prototype[key] = curValue && curValue.__extend__
    ? curValue.__extend__(extension[key])
    : extension[key];
}
</b:text></pre>
<p>Та же логика используется при создании экземпляра класса с авто-расширением, только свойства копируются в сам экземпляр, а не в прототип.</p>
<p>Такое поведение позволяет сокращать количество кода при наследовании классов и создании экземпляров, делая код более простым и читаемым.</p>
<p>Например, все классы созданные <i>basis.Create</i> имеют метод <i>__extend__</i>. Если ему передать в качестве аргумента объект или функцию (не "класс"), то будет создан и возвращен новый класс унаследованный от того, у которого был вызван метод. В противном случае метод вернет то значение, что ему передали. Пример:</p>
<pre><b:text>
// создание класса, у которого в качестве
// свойства childClass другой класс
var MyClass = SomeClass.subclass({
  childClass: ChildClass
});

// явное создание класса
var obj = new MyClass({
  childClass: ChildClass.subclass({ ... })
});

// эквивалентная запись, неявное создание класса
var obj = new MyClass({
  childClass: { ... }
});
</b:text></pre>