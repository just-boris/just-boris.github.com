Основной синтаксис
==================

**УСТАРЕЛО** Скоро будет перенесено в Wiki проекта.

Дальше идет описание самого базового синтаксиса.
Т.е. это то, что точно должны быть и что нужно реализовать в первую очередь.
И этого уже будет достаточно, чтобы пробовать переводить Я.Почту на эти шаблоны.



JPath
-----

В xslt ключевым компонентом является xpath, а здесь у нас будет jpath.
В сущности, это xpath, синтаксис которого приведен более-менее к javascript'у.
Плюс от него отрезано все, что сложно и дорого делать в javascript'е.
Например, в json нет никаких осей (очевидно), поэтому и тут нет никаких осей, кроме child и parent.

    /                   // Корневая нода

    /page               // Абсолютные jpath'ы
    /page/items/item

    page                // Относительные jpath'ы
    items/item

    ./if                // Это тоже относительные jpath
    ./for/domain/id     // Префикс `./` нужен в ситуации, когда в данной позиции может быть и ключевое слово, и jpath.


### Предикаты

    folders/folder[id && count > 0] // Внутри предиката -- expression, см. дальше.


### Индексы

Индексы отличаются от предикатов тем, что выражение является константой в контексте этого jpath:

    items/item[ 24 ]            // Просто числовая константа

    items/item[ $i ]            // Значение $i не зависит от item'а

    items/item[ /page/index ]   // Тоже самое. Значение абсолютного jpath'а не зависит от item'а.


Итого:

  * jpath может быть равным `/` -- указатель на корневую ноду.

  * jpath может начинаться с `/` -- тогда это абсолютный jpath.

  * jpath состоит из одного или более шагов, каждый шаг это `.`, `..`, `*` или `QNAME`.

  * После `*` или `QNAME` может быть предикат/индекс вида `[ expr ]`.

  * Шаги разделены символом `/`.



Expressions
-----------

Примитивы в выражениях:

    23              // числа
    "Hello"         // строки
    $username       // значения переменных
    foo()           // вызовы функций
    ( ... )         // выражения, заключенные в скобки
    foo/bar[ id ]   // jpath


Операторы такие же, как и в xpath, с учетом js-подобности синтаксиса:

    xpath   jpath
    -------------
    or      ||
    and     &&
    =       ==
    !=      !=
    &lt;=   <=
    &lt;    <
    &gt;    >
    &gt;=   >=
    +       +
    -       -
    *       *
    div     /
    mod     %
    not()   !
    |       |

Замечание про `|`. В xpath эта операция делает join/merge/... нодесетов.
У меня же это просто последовательная склейка. При этом дупликаты не удаляются и т.д.
Сделать merge, не модифицируя исходное дерево, невозможно.



Шаблоны и функции
-----------------

В xslt были `xsl:template match="..."` и `xsl:template name="..."`. Плюс еще кастомные функции.
У меня соответственно `match` и `function`.

    match / {
        <html>
            apply page : head
            <body>
                apply page/content
            </body>
        </html>
    }

    match /page : head {
        <head>
            <title>
                page-title(.)
            </title>
        </head>
    }

    function page-title(page, title) {
        if ($page/title) {
            $page/title, " — Яндекс.Почта" // Оператор ',' означает concat.
        } else {
            $title
        }
    }


### Возвращаемое значение функции

Тело функции это и есть ее возвращаемое значение.
Отдельного ключевого слова типа `return` пока что не предусмотрено:

    function foo(a) {
        if ($a > 5) {
            5
        } else {
            $a
        }
    }


### (недодумано) Шаблоны с параметрами

Как-то так:

    match page(title) : title {
        <h1>
            $title
        </h1>
    }



Line-based syntax
-----------------

Есть четкое правило: одна строка -- одно выражение/оператор/конструкция/...
Да, при этом внутри этого выражения может встретиться блок, завернутый в фигурные или круглые скобки,
внутри которого может быть несколько строк-выражений. Но если не учитывать контент этих блоков, то все остальное
будет на одной строке:

    match /items/item : header { ... }

    if (a > 0) { ... } else { ... }

    var a = ( ... )



Statements/operators/...
------------------------

Внутри блоков `{ ... }` и `( ... )` могут быть:

  * XML-строки
  * XML-атрибуты
  * if
  * for
  * Определение переменных / var
  * apply
  * expression / print

Одна строка -- одно что-нибудь.



XML-строки
----------

Строка, начинающаяся на `<` (пробелы вначале не учитываются, конечно).
В ней содержится некий кусок xml'я. Все содержимое строки не обязано быть well-formed.
Но внутри любого блока сумарный xml должен быть well-formed.
При это текстовые ноды допускаются только внутри well-formed фрагментов.

    <h1>Hello, World</h1>

    var xml = (
        <h1>
            "Hello, { $username }"
        </h1>
    )


Вот тут все хорошо. `Hello` находится внутри well-formed фрагмента `<i>...</i>` (при этом вся строка целиком не является well-formed):

    <b><i>Hello</i>
        ", World"
    </b>

А тут не очень:

    <b><i>Hello     // Ошибка! "Висящая" текстовая нода.
    , World</i></b> // Ошибка! Это вообще не xml-строка.


### Невалидный xml внутри блоков

Внутри каждого блока вида `{ ... }` или `( ... )` xml должен быть well-formed:

    var xml = (
        <h1>
            "Hello"
        // Ошибка! Не well-formed xml внутри блока.
    )

    match / {
        <h1>
            "Hello"
        // Ошибка! Не well-formed xml внутри блока.
    }



Раскрытие подвыражений
----------------------

Внутри всех строковых литералов (`"Some text"`) и текстовых нод (`<b>Text</b>`) блоки `{ ... }` заменяются на значение выражения,
находящегося внутри `{ ... }`:

    <h1>Hello, { $username }</h1>

    "Hello, { $username }"

    <h1 class="b-header-{ type }">

Чтобы вывести символы `{` и `}` их нужно удвоить:

    <h1>Hello, {{ username }}</h1> // <h1>Hello, { username }</h1>



XML-атрибуты
------------

Аналог `xsl:attribute`:

    <div>
        @class = "b-folder"
    </div>

Можно добавить что-нибудь к "дефолтному" значению атрибута:

    <div class="b-folder">
        if (user) {
            @class += " b-folder__user"
        }
    </div>

Тоже самое, но по-другому:

    <div>
        @class = "b-folder"
        if (user) {
            @class += " b-folder__user"
        }
    </div>

Сложное выражение:

    <div>
        @class = (
            "b-folder"
            if (count > 0) " b-folder__count"
        )
    </div>



Создание xml-элементов и xml-атрибутов с неконстантными именами
---------------------------------------------------------------

    <div>
        attr $attr-name = "some value"
    </div>

    elem $elem-name {
        attr $attr-name = "some value"
        elem $another-elem-name {
            "some text"
        }
    }



if
--

Аналог `xsl:if` и `xsl:choose` разом:

    if count > 0 {
        ...
    }

    if (id && count > 0) { // Тут скобки для лучшей читаемости, они необязательны.
        ...
    } else {
        ...
    }

    if id {
        ...
    } else if count > 0 {
        ...
    } else {
        ...
    }

Скобки вокруг условия необязательны.


Вместо блока `{ ... }` может быть просто инлайновое выражение:

    if count > 0 "b-count" else "b-empty"

    count > 0 ? "b-count" : "b-empty" // Тоже самое, но через тернарный оператор.



for
---

Аналог `xsl:for-each`:

    <ul>
        for /items/item {
            <li class="{ class }">
                .
            </li>
        }
    </ul>



Определение переменных / var
----------------------------

Аналог `xsl:variable`:

    a = 42
    b = "Hello, " + $username
    c = (
        <h1>
            "Hello, { $username }"
        </h1>
    )

Для наглядности можно использовать ключевое слово var:

    var d = $a

**Важно!** Как и в xslt, переменные неизменяемые.



apply
-----

Аналог `xsl:apply-templates`:

    apply items/item

С модой `title`:

    apply items/item : title

С текущей модой:

    apply items/item : .


### (недодумано) С передачей параметров

    apply items/item($a, $b) : title

### (недодумано) С неконстантной модой

    apply $nodeset : $mode



expression / print
------------------

Строка, которая начинается не с `<`, `@`, `match`, `function`, `if`, `for`, `var`, `apply`,
расценивается как выражение, значение которого будет выведено в этом месте:

    "Hello, World"

    42

    $username

    /items/item[1]

    $a + $b

    ./for/domain/id

Можно для большей наглядности использовать оператор `print`:

    print "Hello, World"

    print 42, $username, /items/item[1], $a + $b



Комментарии
-----------

Бывают блочные:

    /* Comments. */

    /*
        Block
        comments.
    */

И строчные:

    // Comments.

    var a = 42 // Line comments.


При этом важно понимать.
Блочные комментарии могут быть там и только там, где могут быть необязательные пробелы.
Строчные комментарии могут быть только там, где может быть перевод строки.


    var a = //comments

Здесь `//comments` это `(/) / (comments)`.
Потому что после `var a = ` не может быть конца строки, обязательно должно быть выражение.


    var a = foo/* */

Здесь тоже самое. Внутри jpath пробелов (а значит и комментариев) быть не может
(точнее могут быть только внутри предиката `[ ... ]`).
Можно переписать вот так для наглядности:

    var a = (foo/*) * (/)


Поэтому лучше не скупиться на пробелы:

    print "Hello" // Перед и после // рекомендуется ставить пробел.

    var a = 42 /* И тут тоже самое. А лучше блочные комментарии не использовать как строчные */


